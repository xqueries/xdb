package types

import "math"

var (
	// Integer is the date type. Integers are comparable. The name of this type
	// is "Integer".
	Integer = IntegerType{
		typ: typ{
			name: "Integer",
		},
	}
)

// IntegerType is a comparable type.
type IntegerType struct {
	typ
}

// Serialize converts the given value to a byte slice, which can be deserialized
// to obtain a different Value with the same value. The given value has to be an
// IntegerValue. The result of this method can be used by IntegerType.Deserialize.
func (t IntegerType) Serialize(v Value) ([]byte, error) {
	if err := t.ensureHasThisType(v); err != nil {
		return nil, err
	}

	val := v.(IntegerValue).Value
	payload := make([]byte, 8)
	byteOrder.PutUint64(payload, uint64(val))
	return payload, nil
}

// Deserialize converts a given byte slice to an IntegerValue. The input has to be
// one that could have been (or even was) generated by IntegerType.Serialize.
func (t IntegerType) Deserialize(bytes []byte) (Value, error) {
	return NewInteger(int64(byteOrder.Uint64(bytes))), nil
}

// Compare compares two date values. For this to succeed, both values must be of
// type IntegerValue and be not nil. A date later than another date is considered
// larger. This method will return 1 if left>right, 0 if left==right, and -1 if
// left<right.
func (t IntegerType) Compare(left, right Value) (int, error) {
	if err := t.ensureHaveThisType(left, right); err != nil {
		return 0, err
	}

	if left.IsNull() {
		return -1, nil
	} else if right.IsNull() {
		return 1, nil
	}

	leftInteger := left.(IntegerValue).Value
	rightInteger := right.(IntegerValue).Value

	if leftInteger < rightInteger {
		return -1, nil
	} else if rightInteger > leftInteger {
		return 1, nil
	}
	return 0, nil
}

// Add adds the left and right value, producing a new integer value. This only
// works, if left and right are of type integer.
func (t IntegerType) Add(left, right Value) (Value, error) {
	if err := t.ensureHaveThisType(left, right); err != nil {
		return nil, err
	}

	leftInteger := left.(IntegerValue).Value
	rightInteger := right.(IntegerValue).Value

	return NewInteger(leftInteger + rightInteger), nil
}

// Sub subtracts the right from the left value, producing a new integer value.
// This only works, if left and right are of type integer.
func (t IntegerType) Sub(left, right Value) (Value, error) {
	if err := t.ensureHaveThisType(left, right); err != nil {
		return nil, err
	}

	leftInteger := left.(IntegerValue).Value
	rightInteger := right.(IntegerValue).Value

	return NewInteger(leftInteger - rightInteger), nil
}

// Mul multiplicates the left and right value, producing a new integer value.
// This only works, if left and right are of type integer.
func (t IntegerType) Mul(left, right Value) (Value, error) {
	if err := t.ensureHaveThisType(left, right); err != nil {
		return nil, err
	}

	leftInteger := left.(IntegerValue).Value
	rightInteger := right.(IntegerValue).Value

	return NewInteger(leftInteger * rightInteger), nil
}

// Div divides the left by the right value, producing a new real value. This
// only works, if left and right are of type integer.
func (t IntegerType) Div(left, right Value) (Value, error) {
	if err := t.ensureHaveThisType(left, right); err != nil {
		return nil, err
	}

	leftInteger := left.(IntegerValue).Value
	rightInteger := right.(IntegerValue).Value

	return NewReal(float64(leftInteger) / float64(rightInteger)), nil
}

// Mod modulates the left and right value, producing a new integer value. This
// only works, if left and right are of type integer.
func (t IntegerType) Mod(left, right Value) (Value, error) {
	if err := t.ensureHaveThisType(left, right); err != nil {
		return nil, err
	}

	leftInteger := left.(IntegerValue).Value
	rightInteger := right.(IntegerValue).Value

	return NewInteger(leftInteger % rightInteger), nil
}

// Pow exponentiates the left and right value, producing a new integer value.
// This only works, if left and right are of type integer.
func (t IntegerType) Pow(left, right Value) (Value, error) {
	if err := t.ensureHaveThisType(left, right); err != nil {
		return nil, err
	}

	leftInteger := left.(IntegerValue).Value
	rightInteger := right.(IntegerValue).Value

	return NewInteger(int64(math.Pow(float64(leftInteger), float64(rightInteger)))), nil
}
